% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/to_index.R
\name{to_index}
\alias{to_index}
\title{Turns one or multiple vectors into an index (aka group id, aka key)}
\usage{
to_index(
  ...,
  list = NULL,
  sorted = FALSE,
  items.out = FALSE,
  out.list = FALSE,
  items.df = FALSE,
  items.join = "_",
  internal = FALSE
)
}
\arguments{
\item{...}{The vectors to be turned into indexes. Only works for atomic vectors.
If multiple vectors are provided, they should all be of the same length. Notes that
you can alternatively provide a list of vectors with the argument \code{list}.}

\item{list}{An alternative to using \code{...} to pass the input vectors. If provided, it
should be a list of atomic vectors, all of the same length. If this argument is provided,
then \code{...} is ignored.}

\item{sorted}{Logical, default is \code{FALSE}. By default the index order is based on
the order of occurence. Values occurring before have lower index values. Use \code{sorted=TRUE}
to have the index to be sorted based on the vector values. For example \code{c(7, 3, 7, -8)} will be
turned into \code{c(1, 2, 1, 3)} if sorted=FALSE and into \code{c(3, 2, 3, 1)} is \code{sorted=TRUE}.}

\item{items.out}{Logical, default is \code{FALSE}. Whether to return the input values the indexes
refer to. If \code{TRUE}, the attribute \code{"items"} is created with the vector values. Note that
you can return instead a list insteda of an attribute with \code{out.list = TRUE}.}

\item{out.list}{Logical, default is \code{FALSE}. If \code{TRUE}, the function returns a list
of two elements: \code{index} and \code{items}. The \code{items} is the unique input elements
the index refers to.}

\item{items.df}{Logical, default is \code{FALSE}. Whether to return the input elements (to which the index refer) in the form of a data.frame.}

\item{items.join}{Character scalar, default is \code{"_"}. Only used if the items are returned and
there were multiple vectors as input and if \code{items.df=FALSE}. If there are multiple
vectors in input, their unique elements are joined with \code{items.join}, so that a single
character vector represent their combination.}

\item{internal}{Logical, default is \code{FALSE}. If \code{TRUE}, some checks on the data are ignored.}
}
\description{
Turns one or multiple vectors of the same length into an index, that is a integer vector
of the same length ranging from 1 to the number of unique elements in the vectors.
This is equivalent to creating a key.
}
\examples{

x = c("u", "a", "a", "s", "u", "u")
y = c(5, 5, 5, 3, 3, 7)

# By default, the index value is based on order of occurrence
to_index(x)
to_index(y)
to_index(x, y)

# Use the order of the input values with sorted=TRUE
to_index(x, sorted = TRUE)
to_index(y, sorted = TRUE)
to_index(x, y, sorted = TRUE)

# To get the values to which the index refer, use items.out
to_index(x, items.out = TRUE)

# play around with the format of the output
to_index(x, items.out = TRUE, out.list = TRUE)
to_index(x, items.out = TRUE, out.list = TRUE, items.df = TRUE)

# multiple items are by default coerced into a single character string ...
to_index(x, y, items.out = TRUE)

# ... to avoid this, use items.df = TRUE
to_index(x, y, items.out = TRUE, items.df = TRUE)
to_index(x, y, items.out = TRUE, items.df = TRUE, sorted = TRUE)

# NAs considered as valid
x_NA = c("u", NA, "a", "a", "s", "u", "u")
to_index(x_NA, items.out = TRUE)
to_index(x_NA, items.out = TRUE, sorted = TRUE)


}
\author{
Laurent Berge
}
